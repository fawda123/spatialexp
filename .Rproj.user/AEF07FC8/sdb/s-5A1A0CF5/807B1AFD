{
    "contents" : "---\ntitle: \"Hydrologic Connectivity\"\nauthor: \"Tetra Tech\"\ndate: \"Friday, March 04, 2016\"\noutput: html_document\n---\n\n###Introduction\nThe R script contained in this document makes Moran scatterplots of StreamCat (Hill et al. 2015) variables linked to NHDPlus V2 catchments (USEPA and USGS 2012) using the moran.plot function of the spdep package (Bivand et al. 2013, Bivand and Piras 2015) in R. The Ohio (05) vector processing unit of the Mississippi drainage area is used for demonstration purposes. The script imports the data, attaches relevant variables, divides the dataset into HUC4 subregions, calculates upstream and downstream neighbors (directly contiguous) and relative weights, and creates moran scatterplots for hydrologically connected catchments to the index catchments.The plot function is slightly modified from the spdep original to code points for relative watershed size. Several catchments in each subregion are artificially found to have no neighbors, because the \"FromNode\" and \"ToNode\" fields in adjacent catchments do not match. Those no-neighbor catchments are included in the plots as grey dots at the bottom and are also included in the moran test calculation. Final products for each subregion include a text file neighborhood summary and 3 scatterplot figures in .png format. The fourth scatterplot, road density, is included in the code but currently not being run, while issues of \"NA's\" are being addressed.The text file neighbors summary reports the number of catchments with no neighbors for each subregion. \n\n###Methods\nThe first step is to load required libararies and set the working directory. If you are installing these packages for the first time, make sure to check the \"install dependencies\" box. Set the working directory to the location of your files.Next, the script loads and merges datasets on \"COMID.\"\n\n```{r warning=FALSE,message=FALSE}\n##load libararies, set working directory\nlibrary(maptools)\nlibrary(scales)  ###for graphical parameters\nlibrary(spdep)  ###spatial dedendency functions\nlibrary(foreign) \t### reads in .dbf files (could otherwise convert to .csv in excel)\n\nsearch()\n# setwd(\"C:/Users/Diane.Allen@tetratech.com/Documents/ORD_ESDAworking\")\n\n### Read in polygon file.\nMS_05=readShapeSpatial(\"Catchments05.shp\")\nnames(MS_05)  \nnames(MS_05)[2]=\"COMID\"  ## rename FEATUREID COMID to match StreamCat data and FlowlinePlusVAA table\nnames(MS_05); dim(MS_05)  ##  170145 4\n\n### Read in flowline attributes and merge to catchments needed to divide into subregions and for hydrologic connectivity.\nFlowlinePlusVAA=read.dbf(\"FlowlinePlusVAA.dbf\"); dim(FlowlinePlusVAA)  \t###172400  38\nnames(FlowlinePlusVAA)\t###change ComID, R case sensitive!\nnames(FlowlinePlusVAA)[1]=\"COMID\" \n\nMS_05Flow=merge(MS_05,FlowlinePlusVAA[,c(1,4:7,26:27)]); dim(MS_05Flow)\t###170145  10\nsinks=MS_05Flow[MS_05Flow$COMID<0,]; length(sinks)\t### 115 sinks, will not be sorted to subregions\n\n### Read in data files from StreamCat.\n\n##Percent deciduous forest\nNLCD2011=read.csv(\"NLCD2011_Region05.csv\")\nnames(NLCD2011)\t##field of interest 13\n\n##2010 population density and housing unit density\nPopDens=read.csv(\"USCensus2010_Region05.csv\")\nnames(PopDens)\t##fields of interest 6 and 7\n \n##Road density\nRoadDens=read.csv(\"RoadDensity_Region05.csv\")\nnames(RoadDens)  ## field of interest 6\n\n### Merge variables of interest.\nMS_05Plus1=merge(MS_05Flow,NLCD2011[,c(1,13)])\nMS_05Plus2=merge(MS_05Plus1,PopDens[,c(1,6,7)])\nMS_05Plus=merge(MS_05Plus2,RoadDens[,c(1,6)]); dim(MS_05Plus) ###170145  14\nnames(MS_05Plus)\n```\n\nHere, the script adds subregion field for use in loop and count subregions (NA's in \"Reachcode\" represent sinks). I also made an integer subregion field for the \"for loop.\" The density variables are then log(x+1) transformed.\n\n```{r warning=FALSE,message=FALSE}\nMS_05Plus$subregion<-substr(as.character(MS_05Plus$ReachCode),1,4) \nsubregions=unique(na.omit(MS_05Plus$subregion))\nMS_05Plus$subregion.number=as.numeric(MS_05Plus$subregion)\nlength(unique(na.omit(subregions)))### 14\nsummary(MS_05Plus$subregion.number)\n\n### Log(x+1)-transform density variables (housing and populations density have zeroes)\nMS_05Plus$LogHUDen2010<-log10(MS_05Plus$HUDen2010Cat+1)\nMS_05Plus$LogPopDen2010<-log10(MS_05Plus$PopDen2010Cat+1)\nMS_05Plus$LogRdDens<-log10(MS_05Plus$RdDensCat+1)\n```\n\nThis section of the script manually removes sinks (we wanted to know how many affected catchments there were) and runs a \"For loop\" which: \n1) divides dataset into subregions (this process also drops sinks, which do not have reachcodes), 2) defines the modified moran scatterplot function, 3) calculates the necessary moran inputs: the neighbors list (nb.file.i) and spatial weights matrix (listw_05), and 4) generates txt file output of the neighbors summary and png figures of scatterplots. Replace file names and paths in red print with your desired output location.\n\n```{r warning=FALSE,fig.width=7,fig.height=7}\nn=length(unique(na.omit(subregions)))### 14\n\n###Manually removing sinks here. Could be automated. Wanted to know how many were being left out.\nsinks=which(is.na(MS_05Plus$subregion.number)); sinks\n\nMS_05PlusNoSinks=MS_05Plus[1:170030,]; dim(MS_05PlusNoSinks) ###170030  16\nnames(MS_05PlusNoSinks)\n\n\nfor (i in 1:n) {\n\nindex=500+i\n\nMS_05Plus.i=MS_05PlusNoSinks[MS_05PlusNoSinks$subregion.number==index,]\nname.i=paste(\"MS_05.\",i,sep=\"\")\n \n### Modified Moran plot (smaller, scaled symbols; red line; removed influencing point markers)\n### This uses the vast majority of the original code, and other spdep functions, so environment points \n### there at the end\n\nmoran.plot.dot=function (x, listw, zero.policy = TRUE, spChk = NULL, labels = NULL, \n    xlab = NULL, ylab = NULL, quiet = NULL, ...) \n{ \n    if (!inherits(listw, \"listw\")) \n        stop(paste(deparse(substitute(listw)), \"is not a listw object\"))\n    if (is.null(quiet)) \n        quiet <- !get(\"verbose\", envir = .spdepOptions)\n    stopifnot(is.vector(x))\n    stopifnot(is.logical(quiet))\n    if (is.null(zero.policy)) \n        zero.policy <- get(\"zeroPolicy\", envir = .spdepOptions)\n    stopifnot(is.logical(zero.policy))\n    xname <- deparse(substitute(x))\n    if (!is.numeric(x)) \n        stop(paste(xname, \"is not a numeric vector\"))\n    if (any(is.na(x))) \n        stop(\"NA in X\")\n    n <- length(listw$neighbours)\n    if (n != length(x)) \n        stop(\"objects of different length\")\n    if (is.null(spChk)) \n        spChk <- get.spChkOption()\n    if (spChk && !chkIDs(x, listw)) \n        stop(\"Check of data and weights ID integrity failed\")\n    labs <- TRUE\n    if (is.logical(labels) && !labels) \n        labs <- FALSE\n    if (is.null(labels) || length(labels) != n) \n        labels <- as.character(attr(listw, \"region.id\"))\n    wx <- lag.listw(listw, x, zero.policy = zero.policy)\n    if (is.null(xlab)) \n        xlab <- xname\n    if (is.null(ylab)) \n        ylab <- paste(\"spatially lagged\", xname)\n    plot(x, wx, pch=19, col= alpha(\"dark blue\",0.4),cex=5*(MS_05Plus.i$AreaSqKM/MaxArea), xlab = xlab, ylab = ylab, ...)\n    if (zero.policy) {\n        n0 <- wx == 0\n        if (any(n0)) {\n            symbols(x[n0], wx[n0], inches = FALSE, circles = rep(diff(range(x))/80, \n                length(which(n0))), bg = \"grey\", add = TRUE)\n        }\n    }\n    xwx.lm <- lm(wx ~ x)\n    abline(xwx.lm,col=\"red\",lwd=2)\n    abline(h = mean(wx), lty = 2)\n    abline(v = mean(x), lty = 2)\n    #infl.xwx <- influence.measures(xwx.lm)\n    #is.inf <- which(apply(infl.xwx$is.inf, 1, any))\n    #points(x[is.inf], wx[is.inf], pch = 1, cex=1,col=\"blue\")\n    #if (labs) \n    #    text(x[is.inf], wx[is.inf], labels = labels[is.inf], \n    #        pos = 2, cex = 0.7)\n    #rownames(infl.xwx$infmat) <- labels\n    #if (!quiet) \n    #   summary(infl.xwx)\n    #invisible(infl.xwx)\n}\n\nenvironment(moran.plot.dot)<-environment(moran.plot)\n\n\tTotalArea=sum(MS_05Plus.i$AreaSqKM);TotalArea  \n\tMaxArea=max(MS_05Plus.i$AreaSqKM); MaxArea     \n\tMinArea=min(MS_05Plus.i$AreaSqKM); MinArea\t \n\n####modified neighbors function\npoly2nb2 <- function (pl,  row.names = NULL, queen = TRUE) { #pl2 = FlowlinePlusVAA,\n\n    stopifnot(extends(class(pl), \"SpatialPolygons\"))\n    n <- length(slot(pl, \"polygons\"))\n    if (n < 1) \n        stop(\"non-positive number of entities\")\n    if (is.null(row.names)) \n        regid <- row.names(pl)\n    else regid <- NULL\n    if (is.null(regid)) {\n        if (is.null(row.names)) \n            regid <- as.character(1:n)\n        else {\n            if (length(row.names) != n) \n                stop(\"row.names wrong length\")\n            else if (length(unique(row.names)) != length(row.names)) \n                stop(\"non-unique row.names given\")\n            else regid <- row.names\n        }\n    }\n    ans <- vector(mode = \"list\", length = n)\n\n        from0 <- pl@data[,c(\"FromNode\", \"ToNode\")]\n        to0 <-   pl@data[,c(\"FromNode\", \"ToNode\")] #pl2[,c(\"FromNode\", \"ToNode\")]\n#     library(IRanges) \n#     hits <- as.list( findMatches(from0$FromNode, to0$FromNode) \n  \n        for (i in 1:n) {\n         ans[[i]] <- sort(c(which(from0$ToNode[i]== to0$FromNode), #to0$ToNode[\n                which(from0$FromNode[i]== to0$ToNode))  )  # to0$FromNode[\n        }\n        for (i in 1:n) {\n            if (length(ans[[i]]) == 0L) \n                ans[[i]] <- 0L\n            if (length(ans[[i]]) > 1L) \n                ans[[i]] <- sort(ans[[i]])\n        }\n\n    class(ans) <- \"nb\"\n    attr(ans, \"region.id\") <- regid\n    attr(ans, \"call\") <- match.call()\n    if (queen) \n        attr(ans, \"type\") <- \"queen\"\n    else attr(ans, \"type\") <- \"rook\"\n    ans <- sym.attr.nb(ans)\n    ans\n}\n#<environment: namespace:spdep>\n\n\t###make neighbors file\n\tnb.file.i=poly2nb2(MS_05Plus.i,row.names=MS_05Plus.i$COMID,queen=TRUE)\n\tnb.summary.i <- file.path(\"C:\",\"Users\",\"Diane.Allen@tetratech.com\",\"Documents\",\"ORD_ESDAworking\",paste(\"HUC4 - 0\", index,\"_Connectivity.txt\", sep = \"\"))\n\t#print(paste(\"HUC4 - 0\", index, sep = \"\"))\n\tcapture.output(summary(nb.file.i),file=nb.summary.i)\n\tgraph.title<-paste(\"HUC4 - 0\",index, sep = \"\")\n\n\t###making weight list, row standardized, and write to csv file\n\tlistw_05=nb2listw(nb.file.i,style=\"W\",zero.policy=TRUE)\n#\tweights.list.name=paste(\"MS_\",substr(as.character(MS_0510Plus.i$ReachCode),1,4),\"_weights.csv\",sep=\"\")\n#\twrite.csv(listw_05[[3]],title=weights.list.name)\n\n\n######Calls to plot. All but road density working. It fails because there are NA's in the original StreamCat dataset which \n######we are working on\npngpath1.i <- file.path(\"C:\",\"Users\",\"Diane.Allen@tetratech.com\",\"Documents\",\"ORD_ESDAworking\",paste(\"HUC4 - 0\", index, \"ForestConnectivity.png\", sep = \"\"))\npngpath2.i <- file.path(\"C:\",\"Users\",\"Diane.Allen@tetratech.com\",\"Documents\",\"ORD_ESDAworking\",paste(\"HUC4 - 0\", index, \"HousingConnectivity.png\", sep = \"\"))\npngpath3.i <- file.path(\"C:\",\"Users\",\"Diane.Allen@tetratech.com\",\"Documents\",\"ORD_ESDAworking\",paste(\"HUC4 - 0\", index, \"PopulationConnectivity.png\", sep = \"\"))\npngpath4.i <- file.path(\"C:\",\"Users\",\"Diane.Allen@tetratech.com\",\"Documents\",\"ORD_ESDAworking\",paste(\"HUC4 - 0\", index, \"RoadsConnectivity.png\", sep = \"\"))\n\npng(file=pngpath1.i,width=1120,height=850) \nmoran.plot.dot(cex.lab=1.4,MS_05Plus.i$PctDecid2011Cat,listw_05,labels=FALSE,xlab=\"Percent deciduous forest NLCD 2011\",\n               ylab=\"Spatially lagged percent deciduous forest NLCD 2011\", main=graph.title)\nmoran.1=moran.test(MS_05Plus.i$PctDecid2011Cat,listw_05,randomisation=FALSE,zero.policy = TRUE)\nlegend(\"topleft\",legend=c(paste(\"Moran's I statistic =\",round(moran.1[[3]][1],3)),paste(\"p-value=\",moran.1[[2]])),bty=\"n\")\ndev.off()\n#dev.off()\npng(file=pngpath2.i,width=1120,height=850)\nmoran.plot.dot(cex.lab=1.4,MS_05Plus.i$LogHUDen2010,listw_05,labels=FALSE,xlab=\"Housing density 2010\",\n               ylab=\"Spatially lagged housing density 2010\",main=graph.title)\nmoran.2=moran.test(MS_05Plus.i$LogHUDen2010,listw_05,randomisation=FALSE,zero.policy = TRUE)\nlegend(\"topleft\",legend=c(paste(\"Moran's I statistic =\",round(moran.2[[3]][1],3)),paste(\"p-value=\",moran.2[[2]])),bty=\"n\")\ndev.off()\n\npng(file=pngpath3.i,width=1120,height=850)\nmoran.plot.dot(cex.lab=1.4,MS_05Plus.i$LogPopDen2010,listw_05,labels=FALSE,xlab=\"Population density 2010\",\n               ylab=\"Spatially lagged population density 2010\",main=graph.title)\nmoran.3=moran.test(MS_05Plus.i$LogPopDen2010,listw_05,randomisation=FALSE,zero.policy = TRUE)\nlegend(\"topleft\",legend=c(paste(\"Moran's I statistic =\",round(moran.3[[3]][1],3)),paste(\"p-value=\",moran.3[[2]])),bty=\"n\")\ndev.off()\n\n#png(file=pngpath4.i,width=1120,height=850)\n#moran.plot.dot(cex.lab=1.4,MS_05Plus.i$LogRdDens,listw_05,labels=FALSE,xlab=\"Road density\",\n#               ylab=\"Spatially lagged road density\",main=graph.title,zero.policy = TRUE)\n#moran.4=moran.test(MS_05Plus.i$LogRdDens,listw_05,randomisation=FALSE,zero.policy = TRUE)\n#legend(\"topleft\",legend=c(paste(\"Moran's I statistic =\",round(moran.4[[3]][1],3)),paste(\"p-value=\",moran.4[[2]])),bty=\"n\")\n\nmoran.plot.dot(cex.lab=1.4,MS_05Plus.i$PctDecid2011Cat,listw_05,labels=FALSE,xlab=\"Percent deciduous forest NLCD 2011\",\n               ylab=\"Spatially lagged percent deciduous forest NLCD 2011\", main=graph.title)\nmoran.1=moran.test(MS_05Plus.i$PctDecid2011Cat,listw_05,randomisation=FALSE,zero.policy = TRUE)\nlegend(\"topleft\",legend=c(paste(\"Moran's I statistic =\",round(moran.1[[3]][1],3)),paste(\"p-value=\",moran.1[[2]])),bty=\"n\")\n}\nsessionInfo()\n```\n###References\nBivand, R. and N. Lewin-Koh (2015). maptools: Tools for Reading and Handling Spatial Objects. R package version 0.8-37.\n  http://CRAN.R-project.org/package=maptools\n\nBivand, R. and Gianfranco Piras (2015). Comparing Implementations of Estimation Methods for Spatial Econometrics. Journal of\n  Statistical Software, 63(18), 1-36. URL http://www.jstatsoft.org/v63/i18/.\n\nBivand, R. S., Hauke, J., and Kossowski, T. (2013). Computing the Jacobian in Gaussian spatial autoregressive models: An illustrated\n  comparison of available methods. Geographical Analysis, 45(2), 150-179.\n  \nESRI 2012. ArcGIS Desktop: Release 10.1. Redlands, CA: Environmental Systems Research Institute.\n\nHill, Ryan A., Marc H. Weber, Scott G. Leibowitz, Anthony R. Olsen, and Darren J. Thornbrugh, 2015. The Stream-Catchment (StreamCat) Dataset: A Database of Watershed Metrics for the Conterminous United States. Journal of the American Water Resources Association (JAWRA) 1-9. DOI: 10.1111/1752-1688.12372.\n\nHomer, C.G., Dewitz, J.A., Yang, L., Jin, S., Danielson, P., Xian, G., Coulston, J., Herold, N.D., Wickham, J.D., and Megown, K. 2015. Completion of the 2011 National Land Cover Database for the conterminous United States-Representing a decade of land cover change information. Photogrammetric Engineering and Remote Sensing, v. 81, no. 5, p. 345-354\n  \nR Core Team (2014). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria.\n  URL http://www.R-project.org/.\n  \nUSDA-NRCS (United States Department of Agriculture-Natural Resources Conservation Service), United States Geological Survey (USGS), and the Environmental Protection Agency (EPA). Watershed Boundary Dataset (WBD). Available URL: \"http://datagateway.nrcs.usda.gov\" [Accessed 04/02/2016].\n\nUSEPA (U.S. Environmental Protection Agency) and the U.S. Geological Survey (USGS). (2012). National Hydrography Dataset Plus - NHDPlus 2.10\nAvailable URL: \"http://www.epa.gov/waters\"\n  \nWickham, H. (2015). scales: Scale Functions for Visualization. R package version 0.3.0. http://CRAN.R-project.org/package=scales\n",
    "created" : 1457970358135.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "507561553",
    "id" : "807B1AFD",
    "lastKnownWriteTime" : 1457974001,
    "path" : "M:/docs/spatialexp/ConnectivityOutputs/Connectivity_03042016.Rmd",
    "project_path" : "ConnectivityOutputs/Connectivity_03042016.Rmd",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_markdown"
}